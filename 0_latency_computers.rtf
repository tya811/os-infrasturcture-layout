{\rtf1\ansi\ansicpg1252\cocoartf1348\cocoasubrtf170
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural

\f0\fs24 \cf0 layout of containers, kernel, and optimizing functions.\
\
So with containers and Xservers, you all are sending the data to ports, which are physical addresses. \
so what you do to get crazy performance out of these systems is run one instance and link it to a loop and a database of ports that can be added to or subtracted from depending on how many users are on the computer. \
\
what it does is it makes it so that 100000 Xsession instances can be run from a single process in memory. \
\
however, there are two important notes on this architecture. It takes building everything in a linux from scratch fashion, and it takes all the coding to be done in assembly.\
\
what it also does though, is the following: for people doing audio production is less latency. Here\'92s how:\
\
when you stream audio on a chip, say with midi in to alsa modular synth, if you don\'92t change the notes or the intonation while you are playing the notes, you just have all the effects going at the same time and play the keyboard, you can essentially loop the stream as it\'92s being played. so once you type in that key, the processor can have (within 1 ms) probably an hour worth of audio because you don\'92t change the stream, you just increment a loop with all the data in it on either a virtualized or non virtualized register. \
\
the kernel, I cannot stress this enough, needs to be able to run software designed for any os.  I need to be able to run any thing from niresh, puredarwin, qube os, react os, trueos, openbsd etcetera, and build and deploy software for those OSes, even amiga, sun os, freedos, haiku, beOS etcetera because they will all have different theories and some of the software will be more optimized under some of them than others so if you combine them you should be able to pick up and make the best possible os. \
\
however, to run it successfully, and to be able to modify streams of audio and graphics in real time, it takes sending data back to the processor from the GPU and modifying it and then sending it back, but that is fast and easy and will make the computer work with infinite speed, precision and adaptability. \
\
because that way if the user starts moving the mouse over towards a knob on a synth, the computer can prepare and start running potential software as the mouse is being moved,  and then it becomes IO. but you need to analyze trajectory and speed of the mouse to do that stuff.\
\
and then this becomes if you want and if you need, you can play with interrupts all you want. this thing will work like a charm no matter how many people are on it. and you can use 10000000000 instances of blender and k3d and gta5 all at the same time without any lag. \
\
}